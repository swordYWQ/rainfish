<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雨中的YU</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swordYWQ.github.com/"/>
  <updated>2018-04-19T10:14:34.391Z</updated>
  <id>https://swordYWQ.github.com/</id>
  
  <author>
    <name>weiqiang.yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用的跨域解决方案</title>
    <link href="https://swordYWQ.github.com/2018/04/19/cross-origin/"/>
    <id>https://swordYWQ.github.com/2018/04/19/cross-origin/</id>
    <published>2018-04-19T09:42:14.669Z</published>
    <updated>2018-04-19T10:14:34.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h1><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。</p><h1 id="如何跨域"><a href="#如何跨域" class="headerlink" title="如何跨域"></a>如何跨域</h1><p>在项目开发中，时常遇见浏览器接口请求需要跨域访问的情况，此时，我们该如何访问呢？</p><p>下面是几种常用的跨域解决方案:</p><h2 id="通过JSONP跨域"><a href="#通过JSONP跨域" class="headerlink" title="通过JSONP跨域"></a>通过JSONP跨域</h2><p>接口通过jsonp格式请求，请求中需带上callback字段，传递回调方法名，服务端返回结果需要以回调参数的形式返回。</p><p>在页面上我们可以引入不同域上的js脚本文件，但是无法通过ajax访问接口，jsonp的原理是通过一个js脚本回调达到跨域请求的效果。</p><h2 id="服务端设置响应头"><a href="#服务端设置响应头" class="headerlink" title="服务端设置响应头"></a>服务端设置响应头</h2><p>服务端设置Access-Control-Allow-Origin响应头为 *，表示允许所有请求跨域访问，也可以设置为具体域名或IP，达到允许制定地址访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br></pre></td></tr></table></figure><p>此时需要加上前端header头 ‘Content-Type’: ‘application/x-www-form-urlencoded’</p><p>如果跨域请求需要携带cookie信息:</p><p>此时服务端需要设置响应头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;));</span><br></pre></td></tr></table></figure><p>而前端代码ajax请求需要加上withCredentials = true属性，允许携带cookie，</p><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>如果是前后端分离的项目，前端开发阶段可以通过webpack或者gulp构建本地服务器并设置转发。</p><p>如webpack配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">     historyApiFallback: true,</span><br><span class="line">     noInfo: true,</span><br><span class="line">     proxy: &#123;</span><br><span class="line">         &apos;/menu&apos;: &#123;</span><br><span class="line">             target: &apos;https://other-server.example.com&apos;,</span><br><span class="line">             secure: false</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>也可以手写一个node express代理转发,代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const timeout = require(&apos;connect-timeout&apos;);</span><br><span class="line">const proxy = require(&apos;http-proxy-middleware&apos;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">// 这里从环境变量读取配置，方便命令行启动</span><br><span class="line">// HOST 指目标地址</span><br><span class="line">// PORT 服务端口</span><br><span class="line">// const &#123; HOST = &apos;http://api.zhuishushenqi.com&apos;, PORT = &apos;3300&apos; &#125; = process.env;</span><br><span class="line"></span><br><span class="line">// 超时时间</span><br><span class="line">const TIME_OUT = 30 * 1e3;</span><br><span class="line"></span><br><span class="line">// 设置端口</span><br><span class="line">app.set(&apos;port&apos;, 1337);</span><br><span class="line"></span><br><span class="line">// 设置超时 返回超时响应</span><br><span class="line">app.use(timeout(TIME_OUT));</span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  if (!req.timedout) next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 静态页面</span><br><span class="line">// 这里一般设置你的静态资源路径</span><br><span class="line">app.use(&apos;/&apos;, express.static(__dirname));</span><br><span class="line"></span><br><span class="line">// 反向代理（这里把需要进行反代的路径配置到这里即可）</span><br><span class="line">// eg:将/api/test 代理到 $&#123;HOST&#125;/api/test</span><br><span class="line">app.use(&apos;/api1&apos;, proxy(&#123;</span><br><span class="line">  target: &apos;http://api.zhuishushenqi.com&apos;, pathRewrite: &#123;</span><br><span class="line">    &apos;^/api1&apos;: &apos;/&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  changeOrigin: true</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.use(&apos;/api2&apos;, proxy(&#123;</span><br><span class="line">  target: &apos;http://chapterup.zhuishushenqi.com&apos;, pathRewrite: &#123;</span><br><span class="line">    &apos;^/api2&apos;: &apos;/&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  changeOrigin: true</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">// 监听端口</span><br><span class="line">app.listen(app.get(&apos;port&apos;), () =&gt; &#123;</span><br><span class="line">  console.log(`server running @$&#123;app.get(&apos;port&apos;)&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>把这个js文件放在根目录，用node启动，在本地进行ajax请求时，加上特定的url标识，就能正常转发了。</p><p>如果使用nginx作为服务器，可以添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">upstream my_server &#123;                                                         </span><br><span class="line">    server 10.0.0.2:8080;                                                </span><br><span class="line">    keepalive 2000;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;                                                         </span><br><span class="line">    server_name  10.0.0.1;                                               </span><br><span class="line">    client_max_body_size 1024M;</span><br><span class="line"></span><br><span class="line">    location /my/ &#123;</span><br><span class="line">        proxy_pass http://my_server;</span><br><span class="line">        proxy_set_header Host $host:$server_port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我只针对了常用的几种跨域方式进行了介绍,还有不同类型的其他跨域方式，如同源跨域，设置domain，或者postMessage，或者window.name，这里就不一一介绍了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是跨域&quot;&gt;&lt;a href=&quot;#什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域&quot;&gt;&lt;/a&gt;什么是跨域&lt;/h1&gt;&lt;p&gt;跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。&lt;/p&gt;
&lt;h1 id=&quot;如何跨域&quot;&gt;&lt;a href=&quot;#如
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue性能优化之keep-alive</title>
    <link href="https://swordYWQ.github.com/2018/03/06/vue/vue-keepalive/"/>
    <id>https://swordYWQ.github.com/2018/03/06/vue/vue-keepalive/</id>
    <published>2018-03-06T06:26:19.166Z</published>
    <updated>2018-04-19T09:32:37.134Z</updated>
    
    <content type="html"><![CDATA[<p>在web项目中我们经常使用各种缓存在达到提高访问速度的效果，那么，在vue项目中如何使用组件缓存呢。</p><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>keep-alive 是vue官方提供的缓存组件。它是一个抽象组件，在页面中使用keep-alive组件缓存,能有效提高页面响应速度，组件被卸载后不会被destroy掉，而是变成不活跃状态存在内存中，当再次访问组件时直接从内存中获取缓存渲染，而不是重新请求。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>一般使用keep-alive的场景为router-view路由组件或者component动态组件。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>1 只用单独的keep-alive包裹的话，会缓存router-view 渲染的所有组件<br>2 使用include绑定一个数组，只会缓存数组中name相同的组件<br>3 使用exclude绑定一个数组，会缓存除了数组中name相同的其他所有渲染的组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=<span class="string">"cachePages"</span> :exclude=<span class="string">"excludePages"</span>&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>能够实现打开后的组件进行缓存，但关闭标签页后，重新打开组件，组件仍是缓存后的组件，无法实现从内存中移除已缓存的组件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在web项目中我们经常使用各种缓存在达到提高访问速度的效果，那么，在vue项目中如何使用组件缓存呢。&lt;/p&gt;
&lt;h2 id=&quot;keep-alive&quot;&gt;&lt;a href=&quot;#keep-alive&quot; class=&quot;headerlink&quot; title=&quot;keep-alive&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="前端" scheme="https://swordYWQ.github.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://swordYWQ.github.com/tags/vue/"/>
    
      <category term="javascript" scheme="https://swordYWQ.github.com/tags/javascript/"/>
    
      <category term="前端" scheme="https://swordYWQ.github.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://swordYWQ.github.com/2018/03/06/hello-world/"/>
    <id>https://swordYWQ.github.com/2018/03/06/hello-world/</id>
    <published>2018-03-06T01:39:03.923Z</published>
    <updated>2018-03-06T01:39:03.923Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
