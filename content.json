{"meta":{"title":"雨中的YU","subtitle":null,"description":null,"author":"weiqiang.yu","url":"https://swordYWQ.github.com"},"pages":[{"title":"categories","date":"2018-03-06T06:57:33.000Z","updated":"2018-03-06T06:58:04.774Z","comments":false,"path":"categories/index.html","permalink":"https://swordYWQ.github.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-06T06:57:12.000Z","updated":"2018-03-06T06:58:07.043Z","comments":false,"path":"tags/index.html","permalink":"https://swordYWQ.github.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"常用的跨域解决方案","slug":"cross-origin","date":"2018-04-19T09:42:14.669Z","updated":"2018-04-19T10:14:34.391Z","comments":true,"path":"2018/04/19/cross-origin/","link":"","permalink":"https://swordYWQ.github.com/2018/04/19/cross-origin/","excerpt":"","text":"什么是跨域跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。 如何跨域在项目开发中，时常遇见浏览器接口请求需要跨域访问的情况，此时，我们该如何访问呢？ 下面是几种常用的跨域解决方案: 通过JSONP跨域接口通过jsonp格式请求，请求中需带上callback字段，传递回调方法名，服务端返回结果需要以回调参数的形式返回。 在页面上我们可以引入不同域上的js脚本文件，但是无法通过ajax访问接口，jsonp的原理是通过一个js脚本回调达到跨域请求的效果。 服务端设置响应头服务端设置Access-Control-Allow-Origin响应头为 *，表示允许所有请求跨域访问，也可以设置为具体域名或IP，达到允许制定地址访问。 12response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); 此时需要加上前端header头 ‘Content-Type’: ‘application/x-www-form-urlencoded’ 如果跨域请求需要携带cookie信息: 此时服务端需要设置响应头 12response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);response.setHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;)); 而前端代码ajax请求需要加上withCredentials = true属性，允许携带cookie， 代理服务器如果是前后端分离的项目，前端开发阶段可以通过webpack或者gulp构建本地服务器并设置转发。 如webpack配置 123456789devServer: &#123; historyApiFallback: true, noInfo: true, proxy: &#123; &apos;/menu&apos;: &#123; target: &apos;https://other-server.example.com&apos;, secure: false &#125; &#125; 也可以手写一个node express代理转发,代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const express = require(&apos;express&apos;);const path = require(&apos;path&apos;);const timeout = require(&apos;connect-timeout&apos;);const proxy = require(&apos;http-proxy-middleware&apos;);const app = express();// 这里从环境变量读取配置，方便命令行启动// HOST 指目标地址// PORT 服务端口// const &#123; HOST = &apos;http://api.zhuishushenqi.com&apos;, PORT = &apos;3300&apos; &#125; = process.env;// 超时时间const TIME_OUT = 30 * 1e3;// 设置端口app.set(&apos;port&apos;, 1337);// 设置超时 返回超时响应app.use(timeout(TIME_OUT));app.use((req, res, next) =&gt; &#123; if (!req.timedout) next();&#125;);// 静态页面// 这里一般设置你的静态资源路径app.use(&apos;/&apos;, express.static(__dirname));// 反向代理（这里把需要进行反代的路径配置到这里即可）// eg:将/api/test 代理到 $&#123;HOST&#125;/api/testapp.use(&apos;/api1&apos;, proxy(&#123; target: &apos;http://api.zhuishushenqi.com&apos;, pathRewrite: &#123; &apos;^/api1&apos;: &apos;/&apos; &#125;, changeOrigin: true&#125;));app.use(&apos;/api2&apos;, proxy(&#123; target: &apos;http://chapterup.zhuishushenqi.com&apos;, pathRewrite: &#123; &apos;^/api2&apos;: &apos;/&apos; &#125;, changeOrigin: true&#125;))// 监听端口app.listen(app.get(&apos;port&apos;), () =&gt; &#123; console.log(`server running @$&#123;app.get(&apos;port&apos;)&#125;`);&#125;); 把这个js文件放在根目录，用node启动，在本地进行ajax请求时，加上特定的url标识，就能正常转发了。 如果使用nginx作为服务器，可以添加配置 123456789101112131415upstream my_server &#123; server 10.0.0.2:8080; keepalive 2000;&#125;server &#123; listen 80; server_name 10.0.0.1; client_max_body_size 1024M; location /my/ &#123; proxy_pass http://my_server; proxy_set_header Host $host:$server_port; &#125;&#125; 在这里我只针对了常用的几种跨域方式进行了介绍,还有不同类型的其他跨域方式，如同源跨域，设置domain，或者postMessage，或者window.name，这里就不一一介绍了。","categories":[],"tags":[]},{"title":"Vue性能优化之keep-alive","slug":"vue/vue-keepalive","date":"2018-03-06T06:26:19.166Z","updated":"2018-04-19T09:32:37.134Z","comments":true,"path":"2018/03/06/vue/vue-keepalive/","link":"","permalink":"https://swordYWQ.github.com/2018/03/06/vue/vue-keepalive/","excerpt":"","text":"在web项目中我们经常使用各种缓存在达到提高访问速度的效果，那么，在vue项目中如何使用组件缓存呢。 keep-alivekeep-alive 是vue官方提供的缓存组件。它是一个抽象组件，在页面中使用keep-alive组件缓存,能有效提高页面响应速度，组件被卸载后不会被destroy掉，而是变成不活跃状态存在内存中，当再次访问组件时直接从内存中获取缓存渲染，而不是重新请求。 场景一般使用keep-alive的场景为router-view路由组件或者component动态组件。 使用方式1 只用单独的keep-alive包裹的话，会缓存router-view 渲染的所有组件2 使用include绑定一个数组，只会缓存数组中name相同的组件3 使用exclude绑定一个数组，会缓存除了数组中name相同的其他所有渲染的组件 123&lt;keep-alive :include=\"cachePages\" :exclude=\"excludePages\"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 缺陷能够实现打开后的组件进行缓存，但关闭标签页后，重新打开组件，组件仍是缓存后的组件，无法实现从内存中移除已缓存的组件。","categories":[{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://swordYWQ.github.com/tags/vue/"},{"name":"javascript","slug":"javascript","permalink":"https://swordYWQ.github.com/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/tags/前端/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-03-06T01:39:03.923Z","updated":"2018-03-06T01:39:03.923Z","comments":true,"path":"2018/03/06/hello-world/","link":"","permalink":"https://swordYWQ.github.com/2018/03/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}