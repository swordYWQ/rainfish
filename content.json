{"meta":{"title":"雨中的YU","subtitle":null,"description":null,"author":"weiqiang.yu","url":"https://swordYWQ.github.com"},"pages":[{"title":"categories","date":"2018-03-06T06:57:33.000Z","updated":"2018-03-06T06:58:04.774Z","comments":false,"path":"categories/index.html","permalink":"https://swordYWQ.github.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-06T06:57:12.000Z","updated":"2018-03-06T06:58:07.043Z","comments":false,"path":"tags/index.html","permalink":"https://swordYWQ.github.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ios上无法自动播放audio音乐","slug":"ios-audio","date":"2018-08-24T03:41:45.951Z","updated":"2018-08-24T03:45:00.304Z","comments":true,"path":"2018/08/24/ios-audio/","link":"","permalink":"https://swordYWQ.github.com/2018/08/24/ios-audio/","excerpt":"","text":"ios上无法自动播放audio音乐在网页中加入音频作为背景音乐自动播放时，在ios设备中会出现无法自动播放的情况。 由于ios设备限制，用户未有页面交互时，无法自动播放音乐，因此需要手动监听touchstart事件触发播放。 如果音乐播放时手动触发的，不会出现这种情况。 在ios设备中做如下监听: 12345678910111213document.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123; function audioAutoPlay() &#123; document.getElementById(&apos;audio&apos;).play() &#125; audioAutoPlay(); &#125;); //--创建触摸监听，当浏览器打开页面时，触摸屏幕触发事件，进行音频播放 document.addEventListener(&quot;touchstart&quot;, function() &#123; function audioAutoPlay() &#123; document.getElementById(&apos;audio&apos;).play() &#125; audioAutoPlay(); &#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/tags/前端/"},{"name":"移动端","slug":"移动端","permalink":"https://swordYWQ.github.com/tags/移动端/"}]},{"title":"http参数格式转换","slug":"http-param-format","date":"2018-08-24T03:34:31.544Z","updated":"2018-08-24T03:42:08.559Z","comments":true,"path":"2018/08/24/http-param-format/","link":"","permalink":"https://swordYWQ.github.com/2018/08/24/http-param-format/","excerpt":"","text":"http请求参数格式化http请求时，对参数格式有一定要求 get请求参数衔接在请求url后，使用问号(?)分隔并使用与符号(&amp;)连接多个参数 post请求中，当请求方式为formdata时，也需要转换成key=value&amp;key1=value1这样的形式 通常http库会对参数进行一定程度的封装，对get请求不需要特别处理，但post请求有时需要手动处理格式，如axios 此时我们在请求发出前的通用方法中加入如下参数转换方法，即可对参数格式进行转换。 1234567function (obj) &#123; var str = []; for (var p in obj) &#123; str.push(encodeURIComponent(p)\"=\"encodeURIComponent(obj[p])); &#125; return str.join(\"&amp;\"); &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/tags/前端/"},{"name":"http","slug":"http","permalink":"https://swordYWQ.github.com/tags/http/"}]},{"title":"js判断数据类型的方法","slug":"js/js-type","date":"2018-05-11T01:28:47.392Z","updated":"2018-05-11T02:08:15.890Z","comments":true,"path":"2018/05/11/js/js-type/","link":"","permalink":"https://swordYWQ.github.com/2018/05/11/js/js-type/","excerpt":"","text":"在项目中，我们经常需要判断数据的类型，根据数据类型对数据做不同操作，这里总结一下js中判断数据类型的方法。 常用的检测对象类型的方法typeoftypeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：number、boolean、symbol、string、object、undefined、function 等。 1234567891011typeof '' // 'string' 字符串类型 有效typeof 1; // 'number' 数字类型 有效typeof Symbol(); // 'symbol' symbol类型 有效typeof true; // 'boolean' 布尔类型 有效typeof undefined; //'undefined' 未定义 有效typeof new Function(); // 'function' 方法 有效typeof null; //object 无效typeof [] ; //object 无效typeof new Date(); //object 无效typeof new RegExp(); //object 无效 typeof 可以正确判断string,number,symbol,boolean,undefind,function类型，但对于null,array,Date,RegExp均只能返回object字符串，无法对其类型做出正确判断。 instanceofinstanceof 是用来判断A是否为B的实例，如 A instanceof B，如果A是B的实例，则返回true，否则返回false。instanceof检测的是原型。 123456[] instanceof Array // true&#123;&#125; instanceof Object // true[] instanceof Object; // truenew Date() instanceof Object;// truenew Function() instanceof Object // true 可以发现，上面代码返回都是true，instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。 Array.isArray()Array.isArray()是ES5提供的确认某个对象本身是否为Array类型 1Array.isArray([]) //true constructor可以通过检测原型对象的constructor属性判断数据类型 12345678910''.constructor == String // true true.constructor == Boolean // true[].constructor == Array // truedocument.constructor == HTMLDocument // truewindow.constructor == Window // truenew Number(1).constructor == Number // truenew Function().constructor == Function // truenew Date().constructor == Date // truenew Error().constructor == Error // true 部分类型数据本身带有constructor属性，而部分类型需要实例化后才能进行比较。 1231. null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。2. 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object toStringtoString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。 对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。 12345678910111213Object.prototype.toString.call('') ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ; // [object Boolean]Object.prototype.toString.call(Symbol()); //[object Symbol]Object.prototype.toString.call(undefined) ; // [object Undefined]Object.prototype.toString.call(null) ; // [object Null]Object.prototype.toString.call(new Function()) ; // [object Function]Object.prototype.toString.call(new Date()) ; // [object Date]Object.prototype.toString.call([]) ; // [object Array]Object.prototype.toString.call(new RegExp()) ; // [object RegExp]Object.prototype.toString.call(new Error()) ; // [object Error]Object.prototype.toString.call(document) ; // [object HTMLDocument]Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用 如何判断可以根据项目需求使用不同的方式对数据类型进行判断: 对于一般数据类型，如string,number,boolean,symbol,undefined我们可以使用typeof判断。 对于数组的判断一般直接使用ES5自带的Array.isArray(value)方法进行判断。 如果需要判断足够多的数据类型，使用Object.prototype.toString.call(value)是比较方便的。","categories":[{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://swordYWQ.github.com/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/tags/前端/"}]},{"title":"将图片以base64形式嵌入html中提升渲染速度","slug":"optimization-pic","date":"2018-05-10T01:49:21.953Z","updated":"2018-05-11T07:59:50.539Z","comments":true,"path":"2018/05/10/optimization-pic/","link":"","permalink":"https://swordYWQ.github.com/2018/05/10/optimization-pic/","excerpt":"","text":"页面图片优化通常引入图片的时候，会触发多个http请求图片资源，使得页面渲染效果会变差，图片可能会出现空白或层次渲染的情况，体验效果会很差。 将图片转换为base64编码把图片以base64格式后嵌入html，页面渲染速度会更快，图片是直接展现，使得展现效果会更好。 缺点当然，转化为base64格式的图片虽然能提高渲染体验，但也存在一些缺点，由于图片转化成了字符串编码嵌入html中，简介提升了html文件的体积。如果图片较大或较多时，加载html会花费更长的时间，反而会降低初次加载的速度。 解决方案对小于10kb的图片，我们使用base64字符串编码，对大于10kb的图片，我们正常加载或者针对其他方面做优化。 使用方法在使用webpack的项目中，可以通过配置url-loader对图片资源做出处理，小于limit的图片将会转化为base64格式，limit可以根据需要酌情修改。 12345678&#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: &#123; limit: 100000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125; 引用时: 1&lt;img src=\"a.png\" alt=\"\"/&gt; 编译后: 1&lt;img src=&quot;data:image/png;base64:iVBORw0KGgoAAAANSUhEUgAAADg&quot; alt=&quot;&quot;/&gt; 能明显看到src的内容被修改为base64格式。","categories":[{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/tags/前端/"},{"name":"html","slug":"html","permalink":"https://swordYWQ.github.com/tags/html/"}]},{"title":"vue路由懒加载","slug":"vue/vue-router-lazy","date":"2018-05-09T03:28:10.499Z","updated":"2018-05-11T07:59:28.552Z","comments":true,"path":"2018/05/09/vue/vue-router-lazy/","link":"","permalink":"https://swordYWQ.github.com/2018/05/09/vue/vue-router-lazy/","excerpt":"","text":"webpack打包后体积过大我们知道，vue-cli项目默认使用webpack进行打包，打包的时候，会把所有的css,js,vue文件打包成js，页面比较多的时候，最后会生成一个比较大的js文件。 这样的话，在网站进入的时候，需要等待这个大文件下载完成才能进入页面。 解决方法这时我们就可以考虑路由懒加载了，路由懒加载是通过异步加载路由组件，打包后会为每一个组件生成一个js文件，切换路由的时候才会加载该js，减少公用js体积，加快首页渲染速度。 使用方法在配置路由组件的时候，把默认的配置修改一下 123456import Login from '@/login.vue'&#123; path:'/login', name:'login', component: Login&#125; 修改为12345&#123; path:'/login', name:'login', component:(resolve) =&gt; require('***/login.vue',resolve)&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://swordYWQ.github.com/tags/vue/"},{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/tags/前端/"}]},{"title":"常用的跨域解决方案","slug":"cross-origin","date":"2018-04-19T09:42:14.669Z","updated":"2018-05-10T02:10:12.075Z","comments":true,"path":"2018/04/19/cross-origin/","link":"","permalink":"https://swordYWQ.github.com/2018/04/19/cross-origin/","excerpt":"","text":"什么是跨域跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。 如何跨域在项目开发中，时常遇见浏览器接口请求需要跨域访问的情况，此时，我们该如何访问呢？ 下面是几种常用的跨域解决方案: 通过JSONP跨域接口通过jsonp格式请求，请求中需带上callback字段，传递回调方法名，服务端返回结果需要以回调参数的形式返回。 在页面上我们可以引入不同域上的js脚本文件，但是无法通过ajax访问接口，jsonp的原理是通过一个js脚本回调达到跨域请求的效果。 服务端设置响应头服务端设置Access-Control-Allow-Origin响应头为 *，表示允许所有请求跨域访问，也可以设置为具体域名或IP，达到允许制定地址访问。 12response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); 此时需要加上前端header头 ‘Content-Type’: ‘application/x-www-form-urlencoded’ 如果跨域请求需要携带cookie信息: 此时服务端需要设置响应头 12response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);response.setHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;)); 而前端代码ajax请求需要加上withCredentials = true属性，允许携带cookie， 代理服务器如果是前后端分离的项目，前端开发阶段可以通过webpack或者gulp构建本地服务器并设置转发。 如webpack配置 123456789devServer: &#123; historyApiFallback: true, noInfo: true, proxy: &#123; &apos;/menu&apos;: &#123; target: &apos;https://other-server.example.com&apos;, secure: false &#125; &#125; 也可以手写一个node express代理转发,代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const express = require(&apos;express&apos;);const path = require(&apos;path&apos;);const timeout = require(&apos;connect-timeout&apos;);const proxy = require(&apos;http-proxy-middleware&apos;);const app = express();// 这里从环境变量读取配置，方便命令行启动// HOST 指目标地址// PORT 服务端口// const &#123; HOST = &apos;http://api.zhuishushenqi.com&apos;, PORT = &apos;3300&apos; &#125; = process.env;// 超时时间const TIME_OUT = 30 * 1e3;// 设置端口app.set(&apos;port&apos;, 1337);// 设置超时 返回超时响应app.use(timeout(TIME_OUT));app.use((req, res, next) =&gt; &#123; if (!req.timedout) next();&#125;);// 静态页面// 这里一般设置你的静态资源路径app.use(&apos;/&apos;, express.static(__dirname));// 反向代理（这里把需要进行反代的路径配置到这里即可）// eg:将/api/test 代理到 $&#123;HOST&#125;/api/testapp.use(&apos;/api1&apos;, proxy(&#123; target: &apos;http://api.zhuishushenqi.com&apos;, pathRewrite: &#123; &apos;^/api1&apos;: &apos;/&apos; &#125;, changeOrigin: true&#125;));app.use(&apos;/api2&apos;, proxy(&#123; target: &apos;http://chapterup.zhuishushenqi.com&apos;, pathRewrite: &#123; &apos;^/api2&apos;: &apos;/&apos; &#125;, changeOrigin: true&#125;))// 监听端口app.listen(app.get(&apos;port&apos;), () =&gt; &#123; console.log(`server running @$&#123;app.get(&apos;port&apos;)&#125;`);&#125;); 把这个js文件放在根目录，用node启动，在本地进行ajax请求时，加上特定的url标识，就能正常转发了。 如果使用nginx作为服务器，可以添加配置 123456789101112131415upstream my_server &#123; server 10.0.0.2:8080; keepalive 2000;&#125;server &#123; listen 80; server_name 10.0.0.1; client_max_body_size 1024M; location /my/ &#123; proxy_pass http://my_server; proxy_set_header Host $host:$server_port; &#125;&#125; 在这里我只针对了常用的几种跨域方式进行了介绍,还有不同类型的其他跨域方式，如同源跨域，设置domain，或者postMessage，或者window.name，这里就不一一介绍了。","categories":[{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/tags/前端/"},{"name":"http","slug":"http","permalink":"https://swordYWQ.github.com/tags/http/"}]},{"title":"Vue性能优化之keep-alive","slug":"vue/vue-keepalive","date":"2018-03-06T06:26:19.166Z","updated":"2018-08-24T03:50:45.778Z","comments":true,"path":"2018/03/06/vue/vue-keepalive/","link":"","permalink":"https://swordYWQ.github.com/2018/03/06/vue/vue-keepalive/","excerpt":"","text":"在web项目中我们经常使用各种缓存在达到提高访问速度的效果，那么，在vue项目中如何使用组件缓存呢。 keep-alivekeep-alive 是vue官方提供的缓存组件。它是一个抽象组件，在页面中使用keep-alive组件缓存,能有效提高页面响应速度，组件被卸载后不会被destroy掉，而是变成不活跃状态存在内存中，当再次访问组件时直接从内存中获取缓存渲染，而不是重新请求。 场景一般使用keep-alive的场景为router-view路由组件或者component动态组件。 使用方式1 只用单独的keep-alive包裹的话，会缓存router-view 渲染的所有组件2 使用include绑定一个数组，只会缓存数组中name相同的组件3 使用exclude绑定一个数组，会缓存除了数组中name相同的其他所有渲染的组件 123&lt;keep-alive :include=\"cachePages\" :exclude=\"excludePages\"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 缺陷能够实现打开后的组件进行缓存，但关闭标签页后，重新打开组件，组件仍是缓存后的组件，无法实现从内存中移除已缓存的组件。 解决方案经过项目中的测试，发现如果需要比较正常开发多标签页的网站应用，比较适合的方法是使用component组件，组件由component渲染，使用一个数组对组件名进行保存，通过循环生成组件。这种方式能比较方便地实现度标签项目，但缺点是组件打开过多时会造成内存占用过多，因此最好对页面数量进行限制。","categories":[{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://swordYWQ.github.com/tags/vue/"},{"name":"前端","slug":"前端","permalink":"https://swordYWQ.github.com/tags/前端/"}]}]}